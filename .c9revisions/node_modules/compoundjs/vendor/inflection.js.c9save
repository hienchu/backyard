{"ts":1359651604055,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\n * A port of the Rails/ActiveSupport Inflector class\n * http://api.rubyonrails.org/classes/ActiveSupport/Inflector.html\n */\n \nvar inflections = exports.inflections = {\n    plurals: [],\n    singulars: [],\n    uncountables: [],\n    humans: []\n};\n\nvar PLURALS = inflections.plurals,\n    SINGULARS = inflections.singulars,\n    UNCOUNTABLES = inflections.uncountables,\n    HUMANS = inflections.humans;\n    \n/**\n * Specifies a new pluralization rule and its replacement. The rule can either \n * be a string or a regular expression. The replacement should always be a \n * string that may include references to the matched data from the rule.\n */\nvar plural = function (rule, replacement) {\n    //inflections.uncountables.delete(rule) if rule.is_a?(String)\n    //inflections.uncountables.delete(replacement)\n    inflections.plurals.unshift([rule, replacement]);\n}\n\n/**\n * Specifies a new singularization rule and its replacement. The rule can either \n * be a string or a regular expression. The replacement should always be a \n * string that may include references to the matched data from the rule.\n */\nvar singular = function (rule, replacement) {\n    //inflections.uncountables.delete(rule) if rule.is_a?(String)\n    //inflections.uncountables.delete(replacement)\n    inflections.singulars.unshift([rule, replacement]);\n}\n\n/**\n * Add uncountable words that shouldn't be attempted inflected.\n */\nvar uncountable = function (word) {\n    inflections.uncountables.unshift(word);\n}\n\n/**\n * Specifies a new irregular that applies to both pluralization and \n * singularization at the same time. This can only be used for strings, not \n * regular expressions. You simply pass the irregular in singular and plural \n * form.\n *\n * Examples:\n *  irregular(\"octopus\", \"octopi\");\n *  irregular(\"person\", \"people\");\n */\nvar irregular = function (s, p) {\n    //inflections.uncountables.delete(singular);\n    //inflections.uncountables.delete(plural);\n    if (s.substr(0, 1).toUpperCase() == p.substr(0, 1).toUpperCase()) {\n        plural(new RegExp(\"(\" + s.substr(0, 1) + \")\" + s.substr(1) + \"$\", \"i\"), '$1' + p.substr(1));\n        plural(new RegExp(\"(\" + p.substr(0, 1) + \")\" + p.substr(1) + \"$\", \"i\"), '$1' + p.substr(1));\n        singular(new RegExp(\"(\" + p.substr(0, 1) + \")\" + p.substr(1) + \"$\", \"i\"), '$1' + s.substr(1));\n    } else {\n        plural(new RegExp(s.substr(0, 1).toUpperCase() + s.substr(1) + \"$\"), p.substr(0, 1).toUpperCase() + p.substr(1));\n        plural(new RegExp(s.substr(0, 1).toLowerCase() + s.substr(1) + \"$\"), p.substr(0, 1).toLowerCase() + p.substr(1));\n        plural(new RegExp(p.substr(0, 1).toUpperCase() + p.substr(1) + \"$\"), p.substr(0, 1).toUpperCase() + p.substr(1));\n        plural(new RegExp(p.substr(0, 1).toLowerCase() + p.substr(1) + \"$\"), p.substr(0, 1).toLowerCase() + p.substr(1));\n        singular(new RegExp(p.substr(0, 1).toUpperCase() + p.substr(1) + \"$\"), s.substr(0, 1).toUpperCase() + s.substr(1));\n        singular(new RegExp(p.substr(0, 1).toLowerCase() + p.substr(1) + \"$\"), s.substr(0, 1).toLowerCase() + s.substr(1));\n    }\n}\n\n/**\n * Specifies a humanized form of a string by a regular expression rule or by a \n * string mapping. When using a regular expression based replacement, the normal \n * humanize formatting is called after the replacement.\n */\nvar human = function (rule, replacement) {\n    //inflections.uncountables.delete(rule) if rule.is_a?(String)\n    //inflections.uncountables.delete(replacement)\n    inflections.humans.push([rule, replacement]);\n}\n\nplural(/$/, \"s\");\nplural(/s$/i, \"s\");\nplural(/(ax|test)is$/i, \"$1es\");\nplural(/(octop|vir)us$/i, \"$1i\");\nplural(/(alias|status)$/i, \"$1es\");\nplural(/(bu)s$/i, \"$1ses\");\nplural(/(buffal|tomat)o$/i, \"$1oes\");\nplural(/([ti])um$/i, \"$1a\");\nplural(/sis$/i, \"ses\");\nplural(/(?:([^f])fe|([lr])f)$/i, \"$1$2ves\");\nplural(/(hive)$/i, \"$1s\");\nplural(/([^aeiouy]|qu)y$/i, \"$1ies\");\nplural(/(x|ch|ss|sh)$/i, \"$1es\");\nplural(/(matr|vert|ind)(?:ix|ex)$/i, \"$1ices\");\nplural(/([m|l])ouse$/i, \"$1ice\");\nplural(/^(ox)$/i, \"$1en\");\nplural(/(quiz)$/i, \"$1zes\");\n\nsingular(/s$/i, \"\")\nsingular(/(n)ews$/i, \"$1ews\")\nsingular(/([ti])a$/i, \"$1um\")\nsingular(/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$/i, \"$1$2sis\")\nsingular(/(^analy)ses$/i, \"$1sis\")\nsingular(/([^f])ves$/i, \"$1fe\")\nsingular(/(hive)s$/i, \"$1\")\nsingular(/(tive)s$/i, \"$1\")\nsingular(/([lr])ves$/i, \"$1f\")\nsingular(/([^aeiouy]|qu)ies$/i, \"$1y\")\nsingular(/(s)eries$/i, \"$1eries\")\nsingular(/(m)ovies$/i, \"$1ovie\")\nsingular(/(x|ch|ss|sh)es$/i, \"$1\")\nsingular(/([m|l])ice$/i, \"$1ouse\")\nsingular(/(bus)es$/i, \"$1\")\nsingular(/(o)es$/i, \"$1\")\nsingular(/(shoe)s$/i, \"$1\")\nsingular(/(cris|ax|test)es$/i, \"$1is\")\nsingular(/(octop|vir)i$/i, \"$1us\")\nsingular(/(alias|status)es$/i, \"$1\")\nsingular(/^(ox)en/i, \"$1\")\nsingular(/(vert|ind)ices$/i, \"$1ex\")\nsingular(/(matr)ices$/i, \"$1ix\")\nsingular(/(quiz)zes$/i, \"$1\")\nsingular(/(database)s$/i, \"$1\")\n\nirregular(\"person\", \"people\");\nirregular(\"man\", \"men\");\nirregular(\"child\", \"children\");\nirregular(\"sex\", \"sexes\");\nirregular(\"move\", \"moves\");\nirregular(\"cow\", \"kine\");\n\nuncountable(\"equipment\");\nuncountable(\"information\");\nuncountable(\"rice\");\nuncountable(\"money\");\nuncountable(\"species\");\nuncountable(\"series\");\nuncountable(\"fish\");\nuncountable(\"sheep\");\nuncountable(\"jeans\");\n\n/**\n * Returns the plural form of the word in the string.\n */\nexports.pluralize = function (word) {\n    var wlc = word.toLowerCase();\n    \n    for (var i = 0; i < UNCOUNTABLES.length; i++) {\n        var uncountable = UNCOUNTABLES[i];\n        if (wlc == uncountable) {\n            return word;\n        }\n    }\n    \n    for (var i = 0; i < PLURALS.length; i++) {\n        var rule = PLURALS[i][0],\n            replacement = PLURALS[i][1];        \n        if (rule.test(word)) {\n            return word.replace(rule, replacement);\n        }\n    }    \n}\n\n/**\n * Returns the singular form of the word in the string.\n */\nexports.singularize = function (word) {\n    var wlc = word.toLowerCase();\n    \n    for (var i = 0; i < UNCOUNTABLES.length; i++) {\n        var uncountable = UNCOUNTABLES[i];\n        if (wlc == uncountable) {\n            return word;\n        }\n    }\n    \n    for (var i = 0; i < SINGULARS.length; i++) {\n        var rule = SINGULARS[i][0],\n            replacement = SINGULARS[i][1];        \n        if (rule.test(word)) {\n            return word.replace(rule, replacement);\n        }\n    }    \n}\n\n/**\n * Capitalizes the first word and turns underscores into spaces and strips a\n * trailing \"Key\", if any. Like +titleize+, this is meant for creating pretty \n * output.\n *\n * Examples:\n *   \"employeeSalary\" => \"employee salary\"\n *   \"authorKey\"       => \"author\"\n */\nexports.humanize = function (word) {\n    for (var i = 0; i < HUMANS.length; i++) {\n        var rule = HUMANS[i][0],\n            replacement = HUMANS[i][1];        \n        if (rule.test(word)) {\n            word = word.replace(rule, replacement);\n        }\n    }    \n\n    return exports.split(word, \" \").toLowerCase();\n}\n\n/**\n * Split a camel case word in its terms.\n */\nexports.split = function (word, delim) {\n    delim = delim || \" \";\n    var replacement = \"$1\" + delim + \"$2\";\n    return word.\n        replace(/([A-Z]+)([A-Z][a-z])/g, replacement).\n        replace(/([a-z\\d])([A-Z])/g, replacement);\n}\n\n/**\n * Converts a CamelCase word to underscore format.\n */\nexports.underscore = function (word) {\n    return exports.split(word, \"_\").toLowerCase();\n}\n\n/**\n * Converts a CamelCase word to dash (lisp style) format.\n */\nexports.dash = exports.dasherize = function (word) {\n    return exports.split(word, \"-\").toLowerCase();\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":7591}]],"length":7591}
